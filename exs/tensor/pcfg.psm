index(onehot(_),[[i]]).
index(sw(_),[[i]]).
:-set_index_range(i,10).

%% rules
nonterminal(s).
nonterminal(x).

values(s,[[x]]).
values(x,[[a,x,a],[b]]).

%% PCFG program
pcfg(L):- pcfg(s,L-[]).
pcfg(LHS,L0-L1):-
	( nonterminal(LHS) -> simulated_msw(LHS,RHS),proj(RHS,L0-L1)
	; L0 = [LHS|L1]
	).

proj([],L-L).
proj([X|Xs],L0-L1):-
	pcfg(X,L0-L2),proj(Xs,L2-L1).

%% For PRISM simulation
simulated_msw(Sw,Val):-
	get_values(Sw,Values),     % get candidates
	nth0(Index, Values, Val),  % choice (non-deterministic)
	prob_tensor(Sw,[i]),       % distribution vector
	tensor(onehot(Index),[i]). % P(Sw=Val) = dot(distribution vector, onehot vector)

prob_tensor(X,Index):-
	operator(softmax),
	tensor(sw(X),Index).

%% example main program
prism_main([]):-
	format("... building placeholders\n"),
	probf(pcfg([a,a,b,a,a])),
	random_set_seed(1234),
	save_flags('flags.json'),
	Gs=[
		pcfg([a,a,b,a,a]),
		pcfg([a,b,a])
		],
	save_expl_graph(Gs).
	
